<%- include('partials_head') %>

<style>
  /* Fullscreen video background */
  #bg-video {
    position: fixed;
    inset: 0;
    width: 100vw;
    height: 100vh;
    object-fit: cover;
    z-index: 0;
    background: #000;
  }

  /* Layer that holds floating quotes */
  .quotes-layer {
    position: fixed;
    inset: 0;
    z-index: 1;
    pointer-events: none;
    padding: var(--pad, 5vmin);
  }

  .quote {
    position: absolute;
    color: #f2f2f2;
    text-shadow: 0 2px 18px rgba(0,0,0,0.65);
    line-height: 1.2;
    font-weight: 600;
    letter-spacing: 0.2px;
    user-select: none;
    white-space: pre-wrap;
    opacity: 0; /* will fade to target opacity */
  }
</style>

<main class="wall dark" style="padding:0; margin:0;">
  <video id="bg-video" autoplay muted loop playsinline></video>
  <div id="quotes-layer" class="quotes-layer"></div>
</main>

<script src="/socket.io/socket.io.js"></script>
<script>
  // ---- URL params with sensible defaults ----
  const params     = new URLSearchParams(location.search);
  const videoSrc   = params.get('video') || 'video/background.mp4'; // file under /public/
  const maxActive  = 10; // hard lock to 10
  const fontsize   = params.get('fontsize') || '3vmin';             // 2.6–4vmin common
  const fontMinPx  = parseInt(params.get('fontMinPx') || '24', 10);
  const fontMaxPx  = parseInt(params.get('fontMaxPx') || '72', 10);
  const fadeInSec  = parseFloat(params.get('fadeInSec') || '5');    // slow fade-in
  const visibleMin = parseFloat(params.get('visibleMin') || '30');  // on-screen time
  const fadeOutMin = parseFloat(params.get('fadeOutMin') || '30');  // fade-out length
  const maxwVW     = parseFloat(params.get('maxw') || '40');        // max width in vw
  const paddingV   = parseFloat(params.get('pad')  || '5');         // safe padding in vmin

  // ---- Video setup (served from /static which maps to /public) ----
  const video = document.getElementById('bg-video');
  video.src = '/static/' + videoSrc;
  video.onerror = () => { video.remove(); document.body.style.background = '#000'; };

  const layer = document.getElementById('quotes-layer');
  layer.style.setProperty('--pad', paddingV + 'vmin');

  // ---- Active quotes registry ----
  const active = new Set(); // holds DOM elements in insertion order (oldest -> newest)
  let lastIds = [];         // tracks the last server list of approved IDs (newest -> oldest)

  // Create a quote element from an item { id, text, created_at }
  function makeQuote(item) {
    const text = (item && item.text) ? item.text : '';
    const q = document.createElement('div');
    q.className = 'quote';

    // store DB id on the element so we can remove it later
    if (item && item.id != null) {
      q.dataset.id = String(item.id);
    }

    q.textContent = '“' + text + '”';
    q.style.fontSize = `clamp(${fontMinPx}px, ${fontsize}, ${fontMaxPx}px)`;
    q.style.maxWidth = maxwVW + 'vw';
    q.style.transition = `opacity ${fadeInSec}s linear`;
    return q;
  }

  // Best-effort non-overlapping placement
  function placeQuote(el) {
    el.style.visibility = 'hidden';
    layer.appendChild(el);

    // measure
    const box = el.getBoundingClientRect();
    const padPx = Math.max(window.innerWidth, window.innerHeight) * (paddingV/100); // approx vmin -> px
    const W = window.innerWidth  - box.width  - padPx*2;
    const H = window.innerHeight - box.height - padPx*2;

    function collides(rect){
      for (const other of active) {
        const r = other.getBoundingClientRect();
        if (!(rect.right < r.left || rect.left > r.right || rect.bottom < r.top || rect.top > r.bottom)) {
          return true;
        }
      }
      return false;
    }

    let tries = 40;
    while (tries-- > 0) {
      const left = padPx + Math.random() * Math.max(0, W);
      const top  = padPx + Math.random() * Math.max(0, H);
      el.style.left = left + 'px';
      el.style.top  = top  + 'px';
      const rect = el.getBoundingClientRect();
      if (!collides(rect)) break;
    }
    el.style.visibility = '';
  }

  // Fade older items so the oldest is faintest
  function applyOpacityByAge() {
    const els = Array.from(active); // oldest -> newest
    const n = els.length;
    if (n === 0) return;

    // oldest: 0.15, newest: 1.0
    for (let i = 0; i < n; i++) {
      const t = (n === 1) ? 1 : (i / (n - 1));       // 0 oldest, 1 newest
      const op = 0.15 + (t * 0.85);
      els[i].style.opacity = op.toFixed(2);
    }
  }

  // Show -> hold -> fade -> remove
  function runLifecycle(el) {
    active.add(el);

    // fade in to whatever opacity applyOpacityByAge sets
    requestAnimationFrame(() => {
      applyOpacityByAge();
    });

    const visibleMs = visibleMin * 60 * 1000;
    const fadeOutMs = fadeOutMin * 60 * 1000;

    setTimeout(() => {
      // if element was already removed (by admin), skip
      if (!el.isConnected) {
        active.delete(el);
        return;
      }
      el.style.transition = `opacity ${fadeOutMs/1000}s linear`;
      el.style.opacity = '0';
      setTimeout(() => {
        active.delete(el);
        if (el.isConnected) el.remove();
        applyOpacityByAge();
      }, fadeOutMs + 500);
    }, (fadeInSec * 1000) + visibleMs);
  }

  // Spawn logic: expects full item { id, text, created_at }
  function spawn(item) {
    if (!item || !item.text || !item.text.trim()) return;

    // If full, remove oldest so the newest always appears
    if (active.size >= maxActive) {
      const oldest = active.values().next().value;
      if (oldest) {
        active.delete(oldest);
        if (oldest.isConnected) oldest.remove();
      }
    }

    const el = makeQuote(item);
    placeQuote(el);
    layer.appendChild(el);
    runLifecycle(el);
  }

  // Rebuild wall from server list (newest -> oldest)
  function rebuildFrom(itemsNewestFirst) {
    // Clear current
    active.forEach(el => {
      if (el && el.isConnected) el.remove();
    });
    active.clear();

    // Spawn oldest -> newest to preserve insertion order meaningfully
    const items = itemsNewestFirst.slice(0, maxActive).reverse();
    items.forEach((it, i) => setTimeout(() => spawn(it), i * 250));
  }

  // Poll approved list every 3 seconds as a safety net
  async function pollApproved() {
    try {
      const res = await fetch('/api/approved?_=' + Date.now(), { cache: 'no-store' });
      const data = await res.json();
      const items = data.items || [];

      // Server should return newest -> oldest
      const ids = items.slice(0, maxActive).map(it => String(it.id));

      const unchanged = (ids.length === lastIds.length) && ids.every((id, i) => id === lastIds[i]);
      if (unchanged) return;

      lastIds = ids;
      rebuildFrom(items.slice(0, maxActive));
    } catch (e) {
      console.warn('pollApproved failed', e);
    }
  }

  // Initial seed
  async function loadInitial() {
    await pollApproved();
    setInterval(pollApproved, 3000);
  }

  // Handle live approvals and removals
  function bootSocket() {
    const socket = io();

    // New approved item
    socket.on('approved_item', (item) => {
      // Spawn immediately for responsiveness
      spawn(item);
      // Also poll shortly after to guarantee we are in sync and enforce limit
      setTimeout(pollApproved, 300);
    });

    // Removed item
    socket.on('removed_item', (payload) => {
      if (!payload || payload.id == null) return;
      const targetId = String(payload.id);

      const toRemove = [];
      active.forEach(el => {
        if (el.dataset && el.dataset.id === targetId) {
          toRemove.push(el);
        }
      });

      toRemove.forEach(el => {
        active.delete(el);
        if (el.isConnected) el.remove();
      });

      applyOpacityByAge();
      setTimeout(pollApproved, 300);
    });
  }

  loadInitial().then(bootSocket);
</script>

<%- include('partials_foot') %>
