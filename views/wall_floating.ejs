<%- include('partials_head') %>

<style>
  /* Fullscreen video background */
  #bg-video {
    position: fixed;
    inset: 0;
    width: 100vw;
    height: 100vh;
    object-fit: cover;
    z-index: 0;
    background: #000;
  }

  /* Layer that holds floating quotes */
  .quotes-layer {
    position: fixed;
    inset: 0;
    z-index: 1;
    pointer-events: none;
    padding: var(--pad, 5vmin);
  }

  .quote {
    position: absolute;
    color: #f2f2f2;
    text-shadow: 0 2px 18px rgba(0,0,0,0.65);
    line-height: 1.2;
    font-weight: 600;
    letter-spacing: 0.2px;
    user-select: none;
    white-space: pre-wrap;
    opacity: 0;
    will-change: transform, left, top, opacity;
  }
</style>

<main class="wall dark" style="padding:0; margin:0;">
  <video id="bg-video" autoplay muted loop playsinline></video>
  <div id="quotes-layer" class="quotes-layer"></div>
</main>

<script src="/socket.io/socket.io.js"></script>
<script>
  // ---- URL params with sensible defaults ----
  const params     = new URLSearchParams(location.search);
  const videoSrc   = params.get('video') || 'video/background.mp4'; // file under /public/
  const maxActive  = 10; // hard lock to 10
  const fontsize   = params.get('fontsize') || '3vmin';
  const fontMinPx  = parseInt(params.get('fontMinPx') || '24', 10);
  const fontMaxPx  = parseInt(params.get('fontMaxPx') || '72', 10);
  const fadeInSec  = parseFloat(params.get('fadeInSec') || '5');
  const visibleMin = parseFloat(params.get('visibleMin') || '30');
  const fadeOutMin = parseFloat(params.get('fadeOutMin') || '30');
  const maxwVW     = parseFloat(params.get('maxw') || '40');
  const paddingV   = parseFloat(params.get('pad')  || '5');

  // gentle separation tuning
  const nudgeEveryMs = 120;          // how often we run separation
  const nudgeStepPx  = 1.2;          // max px per tick
  const nudgeRangePx = 18;           // start nudging when boxes overlap or are this close

  // opacity tuning
  const minOpacityAtFull = 0.22;     // oldest opacity when there are 10
  const minOpacityAtLow  = 0.85;     // oldest opacity when there are 1–2

  // ---- Video setup ----
  const video = document.getElementById('bg-video');
  video.src = '/static/' + videoSrc;
  video.onerror = () => { video.remove(); document.body.style.background = '#000'; };

  const layer = document.getElementById('quotes-layer');
  layer.style.setProperty('--pad', paddingV + 'vmin');

  // ---- Active quotes registry ----
  // Keep order: oldest -> newest
  const active = new Set();
  // Fast lookup by id
  const byId = new Map();
  // Tracks last server list (newest -> oldest)
  let lastIds = [];

  function clamp(n, a, b) { return Math.max(a, Math.min(b, n)); }

  function getPadPx() {
    // Keep same approximation you used
    return Math.max(window.innerWidth, window.innerHeight) * (paddingV / 100);
  }

  function getRectFor(el) {
    return el.getBoundingClientRect();
  }

  function collidesRect(rect, ignoreEl = null) {
    for (const other of active) {
      if (!other || !other.isConnected) continue;
      if (ignoreEl && other === ignoreEl) continue;
      const r = getRectFor(other);
      const overlap =
        rect.left < (r.right) &&
        rect.right > (r.left) &&
        rect.top < (r.bottom) &&
        rect.bottom > (r.top);
      if (overlap) return true;
    }
    return false;
  }

  // Create a quote element from an item { id, text, created_at }
  function makeQuote(item) {
    const text = (item && item.text) ? item.text : '';
    const q = document.createElement('div');
    q.className = 'quote';

    if (item && item.id != null) {
      q.dataset.id = String(item.id);
    }

    q.textContent = '“' + text + '”';
    q.style.fontSize = `clamp(${fontMinPx}px, ${fontsize}, ${fontMaxPx}px)`;
    q.style.maxWidth = maxwVW + 'vw';
    q.style.transition = `opacity ${fadeInSec}s linear`;
    return q;
  }

  // Best-effort non-overlapping placement (spawn-time only)
  function placeQuote(el) {
    el.style.visibility = 'hidden';
    layer.appendChild(el);

    const box = el.getBoundingClientRect();
    const padPx = getPadPx();
    const W = window.innerWidth  - box.width  - padPx * 2;
    const H = window.innerHeight - box.height - padPx * 2;

    let tries = 60;
    while (tries-- > 0) {
      const left = padPx + Math.random() * Math.max(0, W);
      const top  = padPx + Math.random() * Math.max(0, H);
      el.style.left = left + 'px';
      el.style.top  = top  + 'px';
      const rect = el.getBoundingClientRect();
      if (!collidesRect(rect, el)) break;
    }

    el.style.visibility = '';
  }

  function removeEl(el) {
    if (!el) return;
    const id = el.dataset ? el.dataset.id : null;
    if (id != null) byId.delete(String(id));
    active.delete(el);
    if (el.isConnected) el.remove();
  }

  function removeOldestIfFull() {
    if (active.size < maxActive) return;
    const oldest = active.values().next().value;
    removeEl(oldest);
  }

  // Opacity that scales with count: only becomes faint near 10 items
  function applyOpacityByAge() {
    const els = Array.from(active); // oldest -> newest
    const n = els.length;
    if (n === 0) return;

    // countFactor: 0 at 1 item, 1 at 10 items
    const countFactor = clamp((n - 1) / (maxActive - 1), 0, 1);

    // oldest opacity interpolates from minOpacityAtLow -> minOpacityAtFull as wall fills up
    const minOpacity = (minOpacityAtLow * (1 - countFactor)) + (minOpacityAtFull * countFactor);

    for (let i = 0; i < n; i++) {
      const ageT = (n === 1) ? 1 : (i / (n - 1)); // 0 oldest, 1 newest
      const op = minOpacity + (ageT * (1 - minOpacity));
      els[i].style.opacity = op.toFixed(2);
    }
  }

  // Show -> hold -> fade -> remove (kept)
  function runLifecycle(el) {
    active.add(el);
    const id = el.dataset ? el.dataset.id : null;
    if (id != null) byId.set(String(id), el);

    requestAnimationFrame(() => applyOpacityByAge());

    const visibleMs = visibleMin * 60 * 1000;
    const fadeOutMs = fadeOutMin * 60 * 1000;

    setTimeout(() => {
      if (!el.isConnected) {
        removeEl(el);
        return;
      }
      el.style.transition = `opacity ${fadeOutMs / 1000}s linear`;
      el.style.opacity = '0';
      setTimeout(() => {
        removeEl(el);
        applyOpacityByAge();
      }, fadeOutMs + 500);
    }, (fadeInSec * 1000) + visibleMs);
  }

  // Spawn newest without teleporting others
  function spawn(item) {
    if (!item || !item.text || !item.text.trim()) return;
    const id = (item.id == null) ? null : String(item.id);
    if (id && byId.has(id)) return;

    removeOldestIfFull();

    const el = makeQuote(item);
    placeQuote(el);
    layer.appendChild(el);
    runLifecycle(el);

    // after adding, gently settle to avoid any minor overlaps
    setTimeout(() => settleOnce(), 50);
    setTimeout(() => settleOnce(), 180);
  }

  // Gentle separation: nudge overlapping boxes apart without teleporting
  function settleOnce() {
    const padPx = getPadPx();
    const W = window.innerWidth;
    const H = window.innerHeight;

    const els = Array.from(active);
    if (els.length < 2) return;

    // Work with rects for this tick
    const rects = els.map(el => ({ el, r: el.getBoundingClientRect() }));

    function move(el, dx, dy) {
      const curL = parseFloat(el.style.left || '0');
      const curT = parseFloat(el.style.top  || '0');
      const nextL = curL + dx;
      const nextT = curT + dy;

      // Keep inside padded bounds
      const r = el.getBoundingClientRect();
      const maxL = W - r.width - padPx;
      const maxT = H - r.height - padPx;
      el.style.left = clamp(nextL, padPx, Math.max(padPx, maxL)) + 'px';
      el.style.top  = clamp(nextT, padPx, Math.max(padPx, maxT)) + 'px';
    }

    for (let i = 0; i < rects.length; i++) {
      for (let j = i + 1; j < rects.length; j++) {
        const a = rects[i];
        const b = rects[j];

        const ax = (a.r.left + a.r.right) / 2;
        const ay = (a.r.top + a.r.bottom) / 2;
        const bx = (b.r.left + b.r.right) / 2;
        const by = (b.r.top + b.r.bottom) / 2;

        const dx = ax - bx;
        const dy = ay - by;

        const overlapX = (a.r.width / 2 + b.r.width / 2) - Math.abs(dx);
        const overlapY = (a.r.height / 2 + b.r.height / 2) - Math.abs(dy);

        // If overlapping (or very close), nudge apart
        if (overlapX > -nudgeRangePx && overlapY > -nudgeRangePx) {
          const len = Math.hypot(dx, dy) || 1;
          const ux = dx / len;
          const uy = dy / len;

          // push each a bit
          const push = nudgeStepPx;
          move(a.el,  ux * push,  uy * push);
          move(b.el, -ux * push, -uy * push);
        }
      }
    }
  }

  // Run gentle settling periodically
  setInterval(() => settleOnce(), nudgeEveryMs);

  // Incremental sync: add newest, remove dropped, do not rebuild
  async function pollApproved() {
    try {
      const res = await fetch('/api/approved?_=' + Date.now(), { cache: 'no-store' });
      const data = await res.json();
      const items = (data.items || []).slice(0, maxActive);

      const idsNewest = items.map(it => String(it.id));
      const unchanged = (idsNewest.length === lastIds.length) && idsNewest.every((id, i) => id === lastIds[i]);
      if (unchanged) return;

      // Remove any active elements that are no longer in latest list
      const keep = new Set(idsNewest);
      for (const el of Array.from(active)) {
        const id = el.dataset ? String(el.dataset.id) : null;
        if (id && !keep.has(id)) {
          removeEl(el);
        }
      }

      // Spawn any missing items. Spawn oldest -> newest so they fill naturally.
      // (existing items remain where they are; only new ones get placed)
      for (let i = items.length - 1; i >= 0; i--) {
        const it = items[i];
        const id = String(it.id);
        if (!byId.has(id)) {
          spawn(it);
        }
      }

      // Ensure we never exceed maxActive
      while (active.size > maxActive) {
        removeEl(active.values().next().value);
      }

      // Update tracking
      lastIds = idsNewest;

      // Update opacity
      applyOpacityByAge();
    } catch (e) {
      console.warn('pollApproved failed', e);
    }
  }

  async function loadInitial() {
    await pollApproved();
    setInterval(pollApproved, 3000);
  }

  function bootSocket() {
    const socket = io();

    socket.on('approved_item', (item) => {
      spawn(item);
      applyOpacityByAge();
      setTimeout(pollApproved, 300);
    });

    socket.on('removed_item', (payload) => {
      if (!payload || payload.id == null) return;
      const targetId = String(payload.id);

      const el = byId.get(targetId);
      if (el) removeEl(el);

      applyOpacityByAge();
      setTimeout(pollApproved, 300);
    });
  }

  loadInitial().then(bootSocket);
</script>

<%- include('partials_foot') %>
