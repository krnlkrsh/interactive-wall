<%- include('partials_head') %>

<style>
  /* Zain Light */
  @font-face {
    font-family: "Zain";
    src: url("/static/fonts/zain/Zain-Light.ttf") format("truetype");
    font-weight: 300;
    font-style: normal;
    font-display: swap;
  }

  /* Fullscreen video background */
  #bg-video {
    position: fixed;
    inset: 0;
    width: 100vw;
    height: 100vh;
    object-fit: cover;
    z-index: 0;
    background: #000;
  }

      /* Ghost canvas lives UNDER main quotes */
  #ghost-canvas {
    position: fixed;
    inset: 0;
    z-index: 1;          /* above video (0), below quotes-layer (2) */
    pointer-events: none;
  }

  /* Main/front layer stays on top */
  .quotes-layer {
    position: fixed;
    inset: 0;
    z-index: 2;
    pointer-events: none;
    padding: var(--pad, 5vmin);
  }

  .quote {
    position: absolute;
    color: #f2f2f2;
    text-shadow: 0 2px 18px rgba(0,0,0,0.65);
    line-height: 1.2;
    font-weight: 600;
    letter-spacing: 0.2px;
    user-select: none;
    white-space: pre-wrap;

    /* No transparency */
    opacity: 1;

    /* Smooth motion via GPU transform */
    will-change: transform;

    font-family: "Zain", system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
    font-weight: 300;
  }

</style>

<main class="wall dark" style="padding:0; margin:0;">
  <video id="bg-video" autoplay muted loop playsinline></video>

  <!-- Ghost layer lives UNDER the main quotes -->
    <canvas id="ghost-canvas"></canvas>

  <!-- Main/front layer (unchanged behavior) -->
  <div id="quotes-layer" class="quotes-layer"></div>
</main>

<script src="/socket.io/socket.io.js"></script>
<script>
  // ---- URL params with sensible defaults ----
  const params     = new URLSearchParams(location.search);
  const videoSrc   = params.get('video') || 'video/background.mp4'; // file under /public/
  const maxActive  = 10; // hard lock to 10
  const fontsize   = params.get('fontsize') || '3vmin';
  const fontMinPx  = parseInt(params.get('fontMinPx') || '24', 10);
  const fontMaxPx  = parseInt(params.get('fontMaxPx') || '72', 10);
  const fadeInSec  = parseFloat(params.get('fadeInSec') || '5');
  const visibleMin = parseFloat(params.get('visibleMin') || '30');
  const fadeOutMin = parseFloat(params.get('fadeOutMin') || '30');
  const maxwVW     = parseFloat(params.get('maxw') || '40');
  const paddingV   = parseFloat(params.get('pad')  || '5');

  // size tuning
  const lenMinScale       = 0.78;    // scale for very long texts
  const lenMaxScale       = 1.08;    // scale for very short texts

  // Age shrink per NEW post added (cumulative)
  const AGE_STEP_FACTOR = 0.91; // 9% smaller each new post

  // Smooth repulsion (high FPS)
  const REPULSION_RANGE     = 26;    // px margin where pushing starts
  const REPULSION_STRENGTH  = 0.08;  // acceleration scale
  const DAMPING             = 0.90;  // velocity damping (higher = smoother/floatier)
  const MAX_SPEED           = 3.0;   // px per frame cap

  // ---- Video setup ----
  const video = document.getElementById('bg-video');
  video.src = '/static/' + videoSrc;
  video.onerror = () => { video.remove(); document.body.style.background = '#000'; };

     const ghostCanvas = document.getElementById('ghost-canvas');
  const ghostCtx    = ghostCanvas.getContext('2d', { alpha: true });
  const layer       = document.getElementById('quotes-layer');

  layer.style.setProperty('--pad', paddingV + 'vmin');

    // ---- Front layer registry (unchanged behavior) ----
  // Keep order: oldest -> newest
  const active = new Set();
  // Fast lookup by id (front only)
  const byId = new Map();
  // Tracks last server list for front (newest -> oldest)
  let lastIds = [];

   // ---- Ghost canvas registry ----
  // We store ghost data, not DOM nodes.
  const ghostById = new Map(); // id -> { id, text, x, y, w, h }

  function clamp(n, a, b) { return Math.max(a, Math.min(b, n)); }

  function getPadPx() {
    return Math.max(window.innerWidth, window.innerHeight) * (paddingV / 100);
  }

  // Motion state per element (no layout reads in the animation loop)
  // el -> { baseL, baseT, x, y, vx, vy, w, h }
  const motion = new Map();

  function clampSpeed(v) {
    return clamp(v, -MAX_SPEED, MAX_SPEED);
  }

  // Length -> scale so long text is smaller, short text is larger (bounded)
  function lengthScaleFor(text) {
    const t = String(text || '');
    const len = t.length;

    // Target around 90 chars as "neutral"
    const longness = clamp((len - 30) / (220 - 30), 0, 1);

    // short => lenMaxScale, long => lenMinScale
    return (lenMaxScale * (1 - longness)) + (lenMinScale * longness);
  }

  // Create a quote element from an item { id, text, created_at }
  function makeQuote(item) {
    const text = (item && item.text) ? item.text : '';
    const q = document.createElement('div');
    q.className = 'quote';

    if (item && item.id != null) {
      q.dataset.id = String(item.id);
    }

    q.textContent = text;

    // Base font size stays clamped, then we multiply via transform scale for age+length effects
    q.style.fontSize = `clamp(${fontMinPx}px, ${fontsize}, ${fontMaxPx}px)`;
    q.style.maxWidth = maxwVW + 'vw';

    // store per-item length scale
    q.dataset.lenScale = String(lengthScaleFor(text));

    // NEW: cumulative age steps (how many newer posts arrived since this one)
    q.dataset.ageSteps = '0';

    // transform applied by applyVisuals() and animation loop
    q.style.transform = 'translate3d(0px, 0px, 0px) scale(1)';

    return q;
  }

  // Best-effort non-overlapping placement (spawn-time only)
  function placeQuote(el) {
    el.style.visibility = 'hidden';
    layer.appendChild(el);

    const padPx = getPadPx();

    // Measure once
    const w = el.offsetWidth;
    const h = el.offsetHeight;

    const W = window.innerWidth  - w - padPx * 2;
    const H = window.innerHeight - h - padPx * 2;

    // Random placement, best effort, using existing base positions
    let tries = 60;
    while (tries-- > 0) {
      const left = padPx + Math.random() * Math.max(0, W);
      const top  = padPx + Math.random() * Math.max(0, H);

      let ok = true;
      for (const other of active) {
        if (!other || !other.isConnected) continue;
        const m = motion.get(other);
        if (!m) continue;

        const ox = m.baseL + m.x;
        const oy = m.baseT + m.y;

        const overlap =
          left < (ox + m.w) &&
          (left + w) > ox &&
          top < (oy + m.h) &&
          (top + h) > oy;

        if (overlap) { ok = false; break; }
      }

      if (ok) {
        el.style.left = left + 'px';
        el.style.top  = top  + 'px';
        break;
      }

      // Even if not ok after tries, we still place it somewhere
      if (tries === 0) {
        el.style.left = left + 'px';
        el.style.top  = top  + 'px';
      }
    }

    // Initialize motion state: left/top become base, transform carries motion
    const baseL = parseFloat(el.style.left || '0');
    const baseT = parseFloat(el.style.top  || '0');

    motion.set(el, { baseL, baseT, x: 0, y: 0, vx: 0, vy: 0, w, h });

    el.style.visibility = '';
  }

      // Ghost tuning
  const GHOST_FONT_PX   = 7.7;    // fixed px size
  const GHOST_ALPHA     = 0.28;   // opacity
  const GHOST_MAXW_VW   = 40;     // wrap width
  const GHOST_TRIES     = 80;     // placement attempts
  const GHOST_PAD_EXTRA = 2;      // px spacing between ghosts (best effort)

  function resizeGhostCanvas() {
    const dpr = window.devicePixelRatio || 1;
    const w = Math.floor(window.innerWidth);
    const h = Math.floor(window.innerHeight);

    ghostCanvas.width  = Math.floor(w * dpr);
    ghostCanvas.height = Math.floor(h * dpr);
    ghostCanvas.style.width  = w + 'px';
    ghostCanvas.style.height = h + 'px';

    ghostCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }

  function ghostMaxWidthPx() {
    return (window.innerWidth * (GHOST_MAXW_VW / 100));
  }

  function rectsOverlap(a, b) {
    return (
      a.x < (b.x + b.w) &&
      (a.x + a.w) > b.x &&
      a.y < (b.y + b.h) &&
      (a.y + a.h) > b.y
    );
  }

  function measureWrapped(text) {
    const maxW = ghostMaxWidthPx();
    const raw = String(text || '');
    const words = raw.split(/\s+/);

    const lines = [];
    let line = '';

    for (let i = 0; i < words.length; i++) {
      const test = line ? (line + ' ' + words[i]) : words[i];
      const m = ghostCtx.measureText(test).width;
      if (m <= maxW) {
        line = test;
      } else {
        if (line) lines.push(line);
        line = words[i];
      }
    }
    if (line) lines.push(line);

    let w = 0;
    for (const ln of lines) {
      w = Math.max(w, ghostCtx.measureText(ln).width);
    }

    const lineH = GHOST_FONT_PX * 1.2;
    const h = lines.length * lineH;

    return { w, h, lines, lineH };
  }

  function clearGhostCanvas() {
    ghostCtx.clearRect(0, 0, window.innerWidth, window.innerHeight);
  }

  function redrawGhosts() {
    clearGhostCanvas();

    ghostCtx.save();
    ghostCtx.globalAlpha = GHOST_ALPHA;
    ghostCtx.fillStyle = '#f2f2f2';
    ghostCtx.textBaseline = 'top';
    ghostCtx.font = `300 ${GHOST_FONT_PX}px Zain, system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif`;

    for (const g of ghostById.values()) {
      const m = g._measure;
      if (!m) continue;

      let y = g.y;
      for (const ln of m.lines) {
        ghostCtx.fillText(ln, g.x, y);
        y += m.lineH;
      }
    }

    ghostCtx.restore();
  }

  function placeGhostMeasured(measured, existingBoxes, padPx) {
    const w = measured.w;
    const h = measured.h;

    const maxX = Math.max(padPx, window.innerWidth  - w - padPx);
    const maxY = Math.max(padPx, window.innerHeight - h - padPx);

    for (let t = 0; t < GHOST_TRIES; t++) {
      const x = padPx + Math.random() * Math.max(0, (maxX - padPx));
      const y = padPx + Math.random() * Math.max(0, (maxY - padPx));

      const box = { x, y, w: w + GHOST_PAD_EXTRA, h: h + GHOST_PAD_EXTRA };

      let ok = true;
      for (let i = 0; i < existingBoxes.length; i++) {
        if (rectsOverlap(box, existingBoxes[i])) { ok = false; break; }
      }
      if (ok) return { x, y, box };
    }

    const x = padPx + Math.random() * Math.max(0, (maxX - padPx));
    const y = padPx + Math.random() * Math.max(0, (maxY - padPx));
    return { x, y, box: { x, y, w: w + GHOST_PAD_EXTRA, h: h + GHOST_PAD_EXTRA } };
  }

  function ensureGhost(item, existingBoxes, padPx) {
    const id = String(item.id);
    if (ghostById.has(id)) return;

    ghostCtx.save();
    ghostCtx.font = `300 ${GHOST_FONT_PX}px Zain, system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif`;

    const measured = measureWrapped(item.text || '');
    ghostCtx.restore();

    const placed = placeGhostMeasured(measured, existingBoxes, padPx);

    ghostById.set(id, {
      id,
      text: String(item.text || ''),
      x: placed.x,
      y: placed.y,
      w: measured.w,
      h: measured.h,
      _measure: measured
    });

    existingBoxes.push(placed.box);
  }

  function removeGhostById(id) {
    ghostById.delete(String(id));
  }

  resizeGhostCanvas();
redrawGhosts();

window.addEventListener('resize', () => {
  resizeGhostCanvas();

  const padPx = getPadPx();
  const boxes = [];

  ghostCtx.save();
  ghostCtx.font = `300 ${GHOST_FONT_PX}px Zain, system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif`;

  const entries = Array.from(ghostById.values());
  ghostById.clear();

  for (const g of entries) {
    const measured = measureWrapped(g.text);
    const placed = placeGhostMeasured(measured, boxes, padPx);
    ghostById.set(String(g.id), {
      id: String(g.id),
      text: g.text,
      x: placed.x,
      y: placed.y,
      w: measured.w,
      h: measured.h,
      _measure: measured
    });
    boxes.push(placed.box);
  }

  ghostCtx.restore();
  redrawGhosts();
});

  // ---------- Remove element from FRONT layer ----------
  function removeEl(el) {
    if (!el) return;
    motion.delete(el);
    const id = el.dataset ? el.dataset.id : null;
    if (id != null) byId.delete(String(id));
    active.delete(el);
    if (el.isConnected) el.remove();
  }

  function removeOldestIfFull() {
    if (active.size < maxActive) return;
    const oldest = active.values().next().value;
    removeEl(oldest);
  }

  // Apply size scaling (age + length)
  // Age rule: every time a new post is added, all existing posts get 4% smaller
   function applyVisuals() {
    const els = Array.from(active);
    if (els.length === 0) return;

    for (const el of els) {
      const steps = parseInt(el.dataset.ageSteps || '0', 10) || 0;

      const ageScale = Math.pow(AGE_STEP_FACTOR, steps);
      const lenScale = parseFloat((el.dataset && el.dataset.lenScale) ? el.dataset.lenScale : '1') || 1;

      const finalScale = clamp(ageScale * lenScale, 0.70, 1.15);
      el.dataset.finalScale = String(finalScale);

      // Force equal opacity always
      el.style.opacity = '1';
    }
  }

  // Animation loop: smooth repulsion + transform application (high FPS)
  function animate() {
    const padPx = getPadPx();
    const W = window.innerWidth;
    const H = window.innerHeight;

    const els = Array.from(active).filter(el => el && el.isConnected);
    if (els.length >= 2) {
      // Pairwise repulsion using cached sizes and stored positions
      for (let i = 0; i < els.length; i++) {
        const aEl = els[i];
        const a = motion.get(aEl);
        if (!a) continue;

        for (let j = i + 1; j < els.length; j++) {
          const bEl = els[j];
          const b = motion.get(bEl);
          if (!b) continue;

          const ax = a.baseL + a.x + a.w / 2;
          const ay = a.baseT + a.y + a.h / 2;
          const bx = b.baseL + b.x + b.w / 2;
          const by = b.baseT + b.y + b.h / 2;

          const dx = ax - bx;
          const dy = ay - by;

          const minDistX = (a.w + b.w) / 2 + REPULSION_RANGE;
          const minDistY = (a.h + b.h) / 2 + REPULSION_RANGE;

          const overlapX = minDistX - Math.abs(dx);
          const overlapY = minDistY - Math.abs(dy);

          if (overlapX > 0 && overlapY > 0) {
            const len = Math.hypot(dx, dy) || 1;
            const ux = dx / len;
            const uy = dy / len;

            const push = REPULSION_STRENGTH * Math.min(overlapX, overlapY);

            a.vx += ux * push;
            a.vy += uy * push;
            b.vx -= ux * push;
            b.vy -= uy * push;
          }
        }
      }
    }

    // Integrate + bounds + apply transforms
    for (const el of els) {
      const m = motion.get(el);
      if (!m) continue;

      m.vx *= DAMPING;
      m.vy *= DAMPING;

      m.vx = clampSpeed(m.vx);
      m.vy = clampSpeed(m.vy);

      m.x += m.vx;
      m.y += m.vy;

      const minX = padPx - m.baseL;
      const minY = padPx - m.baseT;
      const maxX = (W - padPx - m.w) - m.baseL;
      const maxY = (H - padPx - m.h) - m.baseT;

      if (m.x < minX) { m.x = minX; m.vx *= -0.25; }
      if (m.y < minY) { m.y = minY; m.vy *= -0.25; }
      if (m.x > maxX) { m.x = maxX; m.vx *= -0.25; }
      if (m.y > maxY) { m.y = maxY; m.vy *= -0.25; }

      const scale = parseFloat(el.dataset.finalScale || '1') || 1;
      el.style.transform = `translate3d(${m.x.toFixed(2)}px, ${m.y.toFixed(2)}px, 0px) scale(${scale.toFixed(3)})`;
      el.style.transformOrigin = 'top left';
    }

    requestAnimationFrame(animate);
  }

  requestAnimationFrame(animate);

  // Show -> hold -> remove (no opacity fade)
  function runLifecycle(el) {
  active.add(el);
  const id = el.dataset ? el.dataset.id : null;
  if (id != null) byId.set(String(id), el);

  requestAnimationFrame(() => applyVisuals());

  // Removed the timed auto-delete.
  // Quotes will now only disappear when:
  // - maxActive is exceeded (removeOldestIfFull),
  // - admin removes/rejects (socket removed_item),
  // - pollApproved sees theyâ€™re no longer in /api/approved.
}
  // Spawn newest without teleporting others
    function spawn(item) {
    if (!item || !item.text || !item.text.trim()) return;
    const id = (item.id == null) ? null : String(item.id);
    if (id && byId.has(id)) return;

    removeOldestIfFull();

    // Every time a new post is added, existing posts get 4% smaller (cumulative)
    for (const existing of active) {
      const cur = parseInt(existing.dataset.ageSteps || '0', 10) || 0;
      existing.dataset.ageSteps = String(cur + 1);
    }

    const el = makeQuote(item);
    el.dataset.ageSteps = '0'; // newest starts at 0 steps

    placeQuote(el);
    layer.appendChild(el);
    runLifecycle(el);

    // re-apply visuals so older ones shrink on each new addition
    setTimeout(() => applyVisuals(), 20);
  }
  // Incremental sync: add newest, remove dropped, do not rebuild
      async function pollApproved() {
    try {
      const res = await fetch('/api/approved?_=' + Date.now(), { cache: 'no-store' });
      const data = await res.json();

      // Server returns up to 2000 now
      const all = (data.items || []);

      // Front: newest maxActive
      const frontItems = all.slice(0, maxActive);
      const frontIdsNewest = frontItems.map(it => String(it.id));

      const unchanged =
        (frontIdsNewest.length === lastIds.length) &&
        frontIdsNewest.every((id, i) => id === lastIds[i]);

      const keepFront = new Set(frontIdsNewest);
      const keepAll   = new Set(all.map(it => String(it.id)));

      // 1) Remove front elements that no longer belong in the FRONT set
      for (const el of Array.from(active)) {
        const id = el.dataset ? String(el.dataset.id) : null;
        if (id && !keepFront.has(id)) {
          removeEl(el);
        }
      }

      // 2) Ghosts: ensure every item NOT in front is in ghost canvas
      // Build existing boxes from current ghosts so we can place new ones with best effort.
      const padPx = getPadPx();
      const ghostBoxes = [];
      for (const g of ghostById.values()) {
        ghostBoxes.push({ x: g.x, y: g.y, w: g.w + 2, h: g.h + 2 });
      }

      let ghostChanged = false;

      for (let i = 0; i < all.length; i++) {
        const it = all[i];
        const id = String(it.id);
        if (!keepFront.has(id)) {
          const before = ghostById.size;
          ensureGhost(it, ghostBoxes, padPx);
          if (ghostById.size !== before) ghostChanged = true;
        }
      }

      // 3) Remove ghosts that are no longer approved
      for (const id of Array.from(ghostById.keys())) {
        if (!keepAll.has(id)) {
          removeGhostById(id);
          ghostChanged = true;
        }
      }

      if (ghostChanged) {
        redrawGhosts();
      }

      // 4) Spawn missing FRONT items (oldest->newest so Set order stays oldest->newest)
      if (!unchanged) {
        for (let i = frontItems.length - 1; i >= 0; i--) {
          const it = frontItems[i];
          const id = String(it.id);
          if (!byId.has(id)) {
            spawn(it);
          }
        }

        while (active.size > maxActive) {
          removeEl(active.values().next().value);
        }

        lastIds = frontIdsNewest;
        applyVisuals();
      }
    } catch (e) {
      console.warn('pollApproved failed', e);
    }
  }

  async function loadInitial() {
    await pollApproved();
    setInterval(pollApproved, 3000);
  }

  function bootSocket() {
    const socket = io();

    socket.on('approved_item', (item) => {
      spawn(item);
      applyVisuals();
      setTimeout(pollApproved, 300);
    });

        socket.on('removed_item', (payload) => {
      if (!payload || payload.id == null) return;
      const targetId = String(payload.id);

      // Remove from front if present
      const el = byId.get(targetId);
      if (el) removeEl(el);

      // Remove from ghost if present
      removeGhostById(targetId);
      redrawGhosts();

      applyVisuals();
      setTimeout(pollApproved, 300);
    });
  }

  loadInitial().then(bootSocket);
</script>

<%- include('partials_foot') %>
 
