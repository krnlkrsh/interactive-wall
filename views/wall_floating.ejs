<%- include('partials_head') %>

<style>
  /* Zain Light */
  @font-face {
    font-family: "Zain";
    src: url("/static/fonts/zain/Zain-Light.ttf") format("truetype");
    font-weight: 300;
    font-style: normal;
    font-display: swap;
  }

  /* Fullscreen video background */
  #bg-video {
    position: fixed;
    inset: 0;
    width: 100vw;
    height: 100vh;
    object-fit: cover;
    z-index: 0;
    background: #000;
  }

    /* Ghost layer lives UNDER main quotes */
  .ghost-layer {
    position: fixed;
    inset: 0;
    z-index: 1;          /* above video (0), below quotes-layer (2) */
    pointer-events: none;
    padding: var(--pad, 5vmin);
  }

  /* Main/front layer stays on top */
  .quotes-layer {
    position: fixed;
    inset: 0;
    z-index: 2;
    pointer-events: none;
    padding: var(--pad, 5vmin);
  }

  .quote {
    position: absolute;
    color: #f2f2f2;
    text-shadow: 0 2px 18px rgba(0,0,0,0.65);
    line-height: 1.2;
    font-weight: 600;
    letter-spacing: 0.2px;
    user-select: none;
    white-space: pre-wrap;

    /* No transparency */
    opacity: 1;

    /* Smooth motion via GPU transform */
    will-change: transform;

    font-family: "Zain", system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
    font-weight: 300;
  }

  /* Ghosts are smaller + transparent and never animated */
  .ghost {
    position: absolute;
    color: #f2f2f2;
    text-shadow: 0 2px 18px rgba(0,0,0,0.35);
    line-height: 1.2;
    font-family: "Zain", system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
    font-weight: 300;
    white-space: pre-wrap;
    opacity: 0.28;       /* transparent ghosts */
    user-select: none;
  }
</style>

<main class="wall dark" style="padding:0; margin:0;">
  <video id="bg-video" autoplay muted loop playsinline></video>

  <!-- Ghost layer lives UNDER the main quotes -->
  <div id="ghost-layer" class="ghost-layer"></div>

  <!-- Main/front layer (unchanged behavior) -->
  <div id="quotes-layer" class="quotes-layer"></div>
</main>

<script src="/socket.io/socket.io.js"></script>
<script>
  // ---- URL params with sensible defaults ----
  const params     = new URLSearchParams(location.search);
  const videoSrc   = params.get('video') || 'video/background.mp4'; // file under /public/
  const maxActive  = 10; // hard lock to 10
  const fontsize   = params.get('fontsize') || '3vmin';
  const fontMinPx  = parseInt(params.get('fontMinPx') || '24', 10);
  const fontMaxPx  = parseInt(params.get('fontMaxPx') || '72', 10);
  const fadeInSec  = parseFloat(params.get('fadeInSec') || '5');
  const visibleMin = parseFloat(params.get('visibleMin') || '30');
  const fadeOutMin = parseFloat(params.get('fadeOutMin') || '30');
  const maxwVW     = parseFloat(params.get('maxw') || '40');
  const paddingV   = parseFloat(params.get('pad')  || '5');

  // size tuning
  const lenMinScale       = 0.78;    // scale for very long texts
  const lenMaxScale       = 1.08;    // scale for very short texts

  // Age shrink per NEW post added (cumulative)
  const AGE_STEP_FACTOR = 0.91; // 9% smaller each new post

  // Smooth repulsion (high FPS)
  const REPULSION_RANGE     = 26;    // px margin where pushing starts
  const REPULSION_STRENGTH  = 0.08;  // acceleration scale
  const DAMPING             = 0.90;  // velocity damping (higher = smoother/floatier)
  const MAX_SPEED           = 3.0;   // px per frame cap

  // ---- Video setup ----
  const video = document.getElementById('bg-video');
  video.src = '/static/' + videoSrc;
  video.onerror = () => { video.remove(); document.body.style.background = '#000'; };

    const ghostLayer = document.getElementById('ghost-layer');
  const layer      = document.getElementById('quotes-layer');

  ghostLayer.style.setProperty('--pad', paddingV + 'vmin');
  layer.style.setProperty('--pad', paddingV + 'vmin');

    // ---- Front layer registry (unchanged behavior) ----
  // Keep order: oldest -> newest
  const active = new Set();
  // Fast lookup by id (front only)
  const byId = new Map();
  // Tracks last server list for front (newest -> oldest)
  let lastIds = [];

  // ---- Ghost layer registry ----
  const ghostById = new Map();   // id -> ghostEl
  const ghostBoxes = [];         // cached placed boxes for overlap checks

  function clamp(n, a, b) { return Math.max(a, Math.min(b, n)); }

  function getPadPx() {
    return Math.max(window.innerWidth, window.innerHeight) * (paddingV / 100);
  }

  // Motion state per element (no layout reads in the animation loop)
  // el -> { baseL, baseT, x, y, vx, vy, w, h }
  const motion = new Map();

  function clampSpeed(v) {
    return clamp(v, -MAX_SPEED, MAX_SPEED);
  }

  // Length -> scale so long text is smaller, short text is larger (bounded)
  function lengthScaleFor(text) {
    const t = String(text || '');
    const len = t.length;

    // Target around 90 chars as "neutral"
    const longness = clamp((len - 30) / (220 - 30), 0, 1);

    // short => lenMaxScale, long => lenMinScale
    return (lenMaxScale * (1 - longness)) + (lenMinScale * longness);
  }

  // Create a quote element from an item { id, text, created_at }
  function makeQuote(item) {
    const text = (item && item.text) ? item.text : '';
    const q = document.createElement('div');
    q.className = 'quote';

    if (item && item.id != null) {
      q.dataset.id = String(item.id);
    }

    q.textContent = text;

    // Base font size stays clamped, then we multiply via transform scale for age+length effects
    q.style.fontSize = `clamp(${fontMinPx}px, ${fontsize}, ${fontMaxPx}px)`;
    q.style.maxWidth = maxwVW + 'vw';

    // store per-item length scale
    q.dataset.lenScale = String(lengthScaleFor(text));

    // NEW: cumulative age steps (how many newer posts arrived since this one)
    q.dataset.ageSteps = '0';

    // transform applied by applyVisuals() and animation loop
    q.style.transform = 'translate3d(0px, 0px, 0px) scale(1)';

    return q;
  }

  // Best-effort non-overlapping placement (spawn-time only)
  function placeQuote(el) {
    el.style.visibility = 'hidden';
    layer.appendChild(el);

    const padPx = getPadPx();

    // Measure once
    const w = el.offsetWidth;
    const h = el.offsetHeight;

    const W = window.innerWidth  - w - padPx * 2;
    const H = window.innerHeight - h - padPx * 2;

    // Random placement, best effort, using existing base positions
    let tries = 60;
    while (tries-- > 0) {
      const left = padPx + Math.random() * Math.max(0, W);
      const top  = padPx + Math.random() * Math.max(0, H);

      let ok = true;
      for (const other of active) {
        if (!other || !other.isConnected) continue;
        const m = motion.get(other);
        if (!m) continue;

        const ox = m.baseL + m.x;
        const oy = m.baseT + m.y;

        const overlap =
          left < (ox + m.w) &&
          (left + w) > ox &&
          top < (oy + m.h) &&
          (top + h) > oy;

        if (overlap) { ok = false; break; }
      }

      if (ok) {
        el.style.left = left + 'px';
        el.style.top  = top  + 'px';
        break;
      }

      // Even if not ok after tries, we still place it somewhere
      if (tries === 0) {
        el.style.left = left + 'px';
        el.style.top  = top  + 'px';
      }
    }

    // Initialize motion state: left/top become base, transform carries motion
    const baseL = parseFloat(el.style.left || '0');
    const baseT = parseFloat(el.style.top  || '0');

    motion.set(el, { baseL, baseT, x: 0, y: 0, vx: 0, vy: 0, w, h });

    el.style.visibility = '';
  }

    // ---------- Ghost helpers ----------
  const GHOST_FONT_PX = 7.7;     // ghosts fixed size
  const GHOST_MAXW_VW = 40;      // keep same wrapping style as front
  const GHOST_TRIES   = 80;

  function rectsOverlap(a, b) {
    return (
      a.x < (b.x + b.w) &&
      (a.x + a.w) > b.x &&
      a.y < (b.y + b.h) &&
      (a.y + a.h) > b.y
    );
  }

  function placeGhost(el) {
    el.style.visibility = 'hidden';
    ghostLayer.appendChild(el);

    const padPx = getPadPx();

    const w = el.offsetWidth;
    const h = el.offsetHeight;

    const W = window.innerWidth  - w - padPx * 2;
    const H = window.innerHeight - h - padPx * 2;

    let placed = false;

    for (let t = 0; t < GHOST_TRIES; t++) {
      const x = padPx + Math.random() * Math.max(0, W);
      const y = padPx + Math.random() * Math.max(0, H);

      const box = { x, y, w, h };

      let ok = true;
      for (let i = 0; i < ghostBoxes.length; i++) {
        if (rectsOverlap(box, ghostBoxes[i])) { ok = false; break; }
      }

      if (ok) {
        el.style.left = x + 'px';
        el.style.top  = y + 'px';
        ghostBoxes.push(box);
        placed = true;
        break;
      }
    }

    if (!placed) {
      const x = padPx + Math.random() * Math.max(0, W);
      const y = padPx + Math.random() * Math.max(0, H);
      el.style.left = x + 'px';
      el.style.top  = y + 'px';
      ghostBoxes.push({ x, y, w, h });
    }

    el.style.visibility = '';
  }

  function makeGhost(item) {
    const text = (item && item.text) ? item.text : '';
    const g = document.createElement('div');
    g.className = 'ghost';
    g.dataset.id = String(item.id);
    g.textContent = text;

    g.style.fontSize = `${GHOST_FONT_PX}px`;
    g.style.maxWidth = GHOST_MAXW_VW + 'vw';

    return g;
  }

  function ensureGhost(item) {
    const id = String(item.id);
    if (ghostById.has(id)) return;

    const g = makeGhost(item);
    placeGhost(g);

    // Newer ghosts end up on top because they are appended later (DOM order).
    ghostById.set(id, g);
  }

  function removeGhostById(id) {
    const el = ghostById.get(id);
    if (!el) return;
    ghostById.delete(id);
    if (el.isConnected) el.remove();
    // Note: we are not compacting ghostBoxes to avoid O(n) rebuilds.
    // Overlap avoidance remains "best effort" for new placements.
  }

  // ---------- Remove element from FRONT layer ----------
  function removeEl(el) {
    if (!el) return;
    motion.delete(el);
    const id = el.dataset ? el.dataset.id : null;
    if (id != null) byId.delete(String(id));
    active.delete(el);
    if (el.isConnected) el.remove();
  }

  function removeOldestIfFull() {
    if (active.size < maxActive) return;
    const oldest = active.values().next().value;
    removeEl(oldest);
  }

  // Apply size scaling (age + length)
  // Age rule: every time a new post is added, all existing posts get 4% smaller
   function applyVisuals() {
    const els = Array.from(active);
    if (els.length === 0) return;

    for (const el of els) {
      const steps = parseInt(el.dataset.ageSteps || '0', 10) || 0;

      const ageScale = Math.pow(AGE_STEP_FACTOR, steps);
      const lenScale = parseFloat((el.dataset && el.dataset.lenScale) ? el.dataset.lenScale : '1') || 1;

      const finalScale = clamp(ageScale * lenScale, 0.70, 1.15);
      el.dataset.finalScale = String(finalScale);

      // Force equal opacity always
      el.style.opacity = '1';
    }
  }

  // Animation loop: smooth repulsion + transform application (high FPS)
  function animate() {
    const padPx = getPadPx();
    const W = window.innerWidth;
    const H = window.innerHeight;

    const els = Array.from(active).filter(el => el && el.isConnected);
    if (els.length >= 2) {
      // Pairwise repulsion using cached sizes and stored positions
      for (let i = 0; i < els.length; i++) {
        const aEl = els[i];
        const a = motion.get(aEl);
        if (!a) continue;

        for (let j = i + 1; j < els.length; j++) {
          const bEl = els[j];
          const b = motion.get(bEl);
          if (!b) continue;

          const ax = a.baseL + a.x + a.w / 2;
          const ay = a.baseT + a.y + a.h / 2;
          const bx = b.baseL + b.x + b.w / 2;
          const by = b.baseT + b.y + b.h / 2;

          const dx = ax - bx;
          const dy = ay - by;

          const minDistX = (a.w + b.w) / 2 + REPULSION_RANGE;
          const minDistY = (a.h + b.h) / 2 + REPULSION_RANGE;

          const overlapX = minDistX - Math.abs(dx);
          const overlapY = minDistY - Math.abs(dy);

          if (overlapX > 0 && overlapY > 0) {
            const len = Math.hypot(dx, dy) || 1;
            const ux = dx / len;
            const uy = dy / len;

            const push = REPULSION_STRENGTH * Math.min(overlapX, overlapY);

            a.vx += ux * push;
            a.vy += uy * push;
            b.vx -= ux * push;
            b.vy -= uy * push;
          }
        }
      }
    }

    // Integrate + bounds + apply transforms
    for (const el of els) {
      const m = motion.get(el);
      if (!m) continue;

      m.vx *= DAMPING;
      m.vy *= DAMPING;

      m.vx = clampSpeed(m.vx);
      m.vy = clampSpeed(m.vy);

      m.x += m.vx;
      m.y += m.vy;

      const minX = padPx - m.baseL;
      const minY = padPx - m.baseT;
      const maxX = (W - padPx - m.w) - m.baseL;
      const maxY = (H - padPx - m.h) - m.baseT;

      if (m.x < minX) { m.x = minX; m.vx *= -0.25; }
      if (m.y < minY) { m.y = minY; m.vy *= -0.25; }
      if (m.x > maxX) { m.x = maxX; m.vx *= -0.25; }
      if (m.y > maxY) { m.y = maxY; m.vy *= -0.25; }

      const scale = parseFloat(el.dataset.finalScale || '1') || 1;
      el.style.transform = `translate3d(${m.x.toFixed(2)}px, ${m.y.toFixed(2)}px, 0px) scale(${scale.toFixed(3)})`;
      el.style.transformOrigin = 'top left';
    }

    requestAnimationFrame(animate);
  }

  requestAnimationFrame(animate);

  // Show -> hold -> remove (no opacity fade)
  function runLifecycle(el) {
  active.add(el);
  const id = el.dataset ? el.dataset.id : null;
  if (id != null) byId.set(String(id), el);

  requestAnimationFrame(() => applyVisuals());

  // Removed the timed auto-delete.
  // Quotes will now only disappear when:
  // - maxActive is exceeded (removeOldestIfFull),
  // - admin removes/rejects (socket removed_item),
  // - pollApproved sees theyâ€™re no longer in /api/approved.
}
  // Spawn newest without teleporting others
    function spawn(item) {
    if (!item || !item.text || !item.text.trim()) return;
    const id = (item.id == null) ? null : String(item.id);
    if (id && byId.has(id)) return;

    removeOldestIfFull();

    // Every time a new post is added, existing posts get 4% smaller (cumulative)
    for (const existing of active) {
      const cur = parseInt(existing.dataset.ageSteps || '0', 10) || 0;
      existing.dataset.ageSteps = String(cur + 1);
    }

    const el = makeQuote(item);
    el.dataset.ageSteps = '0'; // newest starts at 0 steps

    placeQuote(el);
    layer.appendChild(el);
    runLifecycle(el);

    // re-apply visuals so older ones shrink on each new addition
    setTimeout(() => applyVisuals(), 20);
  }
  // Incremental sync: add newest, remove dropped, do not rebuild
    async function pollApproved() {
    try {
      const res = await fetch('/api/approved?_=' + Date.now(), { cache: 'no-store' });
      const data = await res.json();

      // Server can return up to 2000 now
      const all = (data.items || []);

      // Front: newest maxActive
      const frontItems = all.slice(0, maxActive);
      const frontIdsNewest = frontItems.map(it => String(it.id));

      const unchanged =
        (frontIdsNewest.length === lastIds.length) &&
        frontIdsNewest.every((id, i) => id === lastIds[i]);

      // Build keep sets for reconciliation
      const keepFront = new Set(frontIdsNewest);
      const keepAll   = new Set(all.map(it => String(it.id)));

      // 1) Remove front elements that no longer belong in the FRONT set
      for (const el of Array.from(active)) {
        const id = el.dataset ? String(el.dataset.id) : null;
        if (id && !keepFront.has(id)) {
          removeEl(el);
        }
      }

      // 2) Ensure ghosts exist for everything NOT in front
      //    Ghosts will accumulate up to the server limit and stay unless removed from approved.
      for (let i = 0; i < all.length; i++) {
        const it = all[i];
        const id = String(it.id);
        if (!keepFront.has(id)) {
          ensureGhost(it);
        }
      }

      // 3) Remove ghosts that are no longer approved (admin removed/rejected)
      for (const [id, gEl] of ghostById.entries()) {
        if (!keepAll.has(id)) {
          removeGhostById(id);
        }
      }

      // 4) Spawn missing FRONT items (oldest->newest so order is correct for Set)
      if (!unchanged) {
        for (let i = frontItems.length - 1; i >= 0; i--) {
          const it = frontItems[i];
          const id = String(it.id);
          if (!byId.has(id)) {
            spawn(it);
          }
        }

        while (active.size > maxActive) {
          removeEl(active.values().next().value);
        }

        lastIds = frontIdsNewest;
        applyVisuals();
      }
    } catch (e) {
      console.warn('pollApproved failed', e);
    }
  }

  async function loadInitial() {
    await pollApproved();
    setInterval(pollApproved, 3000);
  }

  function bootSocket() {
    const socket = io();

    socket.on('approved_item', (item) => {
      spawn(item);
      applyVisuals();
      setTimeout(pollApproved, 300);
    });

        socket.on('removed_item', (payload) => {
      if (!payload || payload.id == null) return;
      const targetId = String(payload.id);

      // Remove from front if present
      const el = byId.get(targetId);
      if (el) removeEl(el);

      // Remove from ghost if present
      removeGhostById(targetId);

      applyVisuals();
      setTimeout(pollApproved, 300);
    });
  }

  loadInitial().then(bootSocket);
</script>

<%- include('partials_foot') %>
 
