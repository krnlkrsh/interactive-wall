<%- include('partials_head') %>
  <main class="wall dark" style="padding:0; margin:0;">
    <video id="bg-video" autoplay muted loop playsinline></video>
    <div id="quotes-layer" class="quotes-layer"></div>
  </main>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    // Read URL params with defaults
    const params = new URLSearchParams(location.search);
    const videoSrc   = params.get('video') || 'video/background.mp4'; // put file in /public/video/
    const maxActive  = parseInt(params.get('maxActive') || '6', 10);
    const fontsize   = params.get('fontsize') || '3vmin';  // eg 2.6vmin–4vmin
    const fontMinPx  = parseInt(params.get('fontMinPx') || '24', 10);
    const fontMaxPx  = parseInt(params.get('fontMaxPx') || '64', 10);
    const fadeInSec  = parseFloat(params.get('fadeInSec') || '5');     // slow fade in
    const visibleMin = parseFloat(params.get('visibleMin') || '30');   // stay on screen
    const fadeOutMin = parseFloat(params.get('fadeOutMin') || '30');   // fade out length
    const maxwVW     = parseFloat(params.get('maxw') || '40');         // max width in vw
    const paddingV   = parseFloat(params.get('pad')  || '5');          // safe padding in vmin

    // Video
    const video = document.getElementById('bg-video');
    video.src = '/static/' + videoSrc;
    video.onerror = () => { video.remove(); document.body.style.background = '#000'; };

    const layer = document.getElementById('quotes-layer');
    layer.style.setProperty('--pad', paddingV + 'vmin');

    // Active quotes registry
    const active = new Set();

    // Create a quote element
    function makeQuote(text){
      const q = document.createElement('div');
      q.className = 'quote';
      q.textContent = '“' + text + '”';
      q.style.fontSize = `clamp(${fontMinPx}px, ${fontsize}, ${fontMaxPx}px)`;
      q.style.maxWidth = maxwVW + 'vw';
      q.style.opacity = '0';
      q.style.transition = `opacity ${fadeInSec}s linear`;
      return q;
    }

    // Place without overlapping others (simple best-effort)
    function placeQuote(el){
      el.style.visibility = 'hidden';
      layer.appendChild(el);
      // Get size
      const box = el.getBoundingClientRect();
      const padPx = Math.max(window.innerWidth, window.innerHeight) * (paddingV/100); // approx vmin
      const W = window.innerWidth  - box.width  - padPx*2;
      const H = window.innerHeight - box.height - padPx*2;

      function collides(rect){
        for (const other of active) {
          const r = other.getBoundingClientRect();
          if (!(rect.right < r.left || rect.left > r.right || rect.bottom < r.top || rect.top > r.bottom)) {
            return true;
          }
        }
        return false;
      }

      let tries = 40;
      while (tries-- > 0) {
        const left = padPx + Math.random() * Math.max(0, W);
        const top  = padPx + Math.random() * Math.max(0, H);
        el.style.left = left + 'px';
        el.style.top  = top  + 'px';
        const rect = el.getBoundingClientRect();
        if (!collides(rect)) break;
      }
      el.style.visibility = '';
    }

    // Show, hold, fade, remove
    function runLifecycle(el){
      active.add(el);
      requestAnimationFrame(() => { el.style.opacity = '1'; }); // fade in
      const visibleMs = visibleMin * 60 * 1000;
      const fadeOutMs = fadeOutMin * 60 * 1000;
      setTimeout(() => {
        el.style.transition = `opacity ${fadeOutMs/1000}s linear`;
        el.style.opacity = '0';
        setTimeout(() => { active.delete(el); el.remove(); }, fadeOutMs + 500);
      }, (fadeInSec * 1000) + visibleMs);
    }

    // Spawn logic
    function spawn(text){
      if (!text || !text.trim()) return;
      if (active.size >= maxActive) return; // simple cap
      const el = makeQuote(text.trim());
      placeQuote(el);
      layer.appendChild(el);
      runLifecycle(el);
    }

    // Load initial approved items and seed a few
    async function loadInitial(){
      const res = await fetch('/api/approved');
      const data = await res.json();
      const items = data.items || [];
      // Seed up to maxActive, use the most recent ones
      const pick = items.slice(-maxActive);
      pick.forEach((it, i) => setTimeout(() => spawn(it.text), i*3000));
    }

    // Live approvals
    function bootSocket(){
      const socket = io();
      socket.on('approved_item', (item) => {
        spawn(item.text);
      });
    }

    loadInitial().then(bootSocket);
  </script>
<%- include('partials_foot') %>
